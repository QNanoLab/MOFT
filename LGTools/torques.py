# -*- coding: utf-8 -*-
# %%
"""
ANALITIC CALCULATIONS OF OPTICAL TORQUES FOR DISPLACED FOCUSED BEAMS. Created on Wed Sep 18 2024

@author: Iker GÃ³mez Viloria

The formulas shown in this document are adressed and explained in the paper ... 
"""

import numpy as np
from scipy import constants as spc
import cmath

def Z_Torques_Analitic_Calculation(l1,l2,p,k,C,Cn,alpha_l,beta_l):
    """
    Optical torques in z direction generated by ON-AXIS cylindrically symmetric monochromatic beams on spherical particles. 
    """    

    T_z = np.real(alpha_l*np.conj(alpha_l) + beta_l*np.conj(beta_l) + np.sqrt(2)*np.real(alpha_l))
    
    if p!=0:
        A_j = C*np.sqrt(2)
        m_z = l1 + p
        TZ = - np.real(spc.epsilon_0/(4*(k)**3) * m_z * np.dot((A_j * np.conj(A_j)), T_z))

    else:
        m_z = l1 + 1
        A_j = C
        TZ1 = - np.real(spc.epsilon_0/(4*(k)**3) * m_z * np.dot((A_j * np.conj(A_j)), T_z))
        m_z = l2 - 1
        A_j = Cn
        TZm1 = - np.real(spc.epsilon_0/(4*(k)**3) * m_z * np.dot((A_j * np.conj(A_j)), T_z))
        TZ=TZ1+TZm1

    return TZ

def Z_Torques_Analitic_Calculation_l(l,p,k,m_array,C,Cn,alpha_l,beta_l):
    """
    Optical torques in z direction generated by OFF-AXIS cylindrically symmetric monochromatic beams on spherical particles. 
    """

    T_z = np.real(alpha_l[l]*np.conj(alpha_l[l]) + beta_l[l]*np.conj(beta_l[l]) + np.sqrt(2)*np.real(alpha_l[l]))
    
    if p!=0:
        A_j = C*np.sqrt(2)
        TZ = - np.real(spc.epsilon_0/(4*(k)**3) * np.sum(m_array * A_j[l] * np.conj(A_j[l]) * T_z))

    else:
        A_j = C
        TZ1 = - np.real(spc.epsilon_0/(4*(k)**3) * np.sum(m_array * A_j[l] * np.conj(A_j[l]) * T_z))
        A_j = Cn
        TZm1 = - np.real(spc.epsilon_0/(4*(k)**3) * np.sum(m_array * A_j[l] * np.conj(A_j[l]) * T_z))
        TZ=TZ1+TZm1

    return TZ

def XY_Torques_Analitic_Calculation_l(l,p,k,l_max,m_array,C,Cn,alpha_l,beta_l):
    """
    Optical torques in x and y directions generated by OFF-AXIS cylindrically symmetric monochromatic beams on spherical particles. 
    """

    m_lim = l_max-l
    m_mlim = -m_lim-1
    m_2mlim = -m_lim+1

    if m_mlim == 0:
        m_mlim = None
    if m_2mlim == 0:
        m_2mlim = None

    Alpha_4=(l-m_array)*(l+m_array+1)
    T_x = np.real(alpha_l[l]*np.conj(alpha_l[l]) + beta_l[l]*np.conj(beta_l[l]) + np.sqrt(2)*np.real(alpha_l[l]))

    if p==0:
        A = C
        Am = Cn
        T_xyl =  - spc.epsilon_0/(4*(k)**3) * np.dot(np.asarray([cmath.sqrt(x) for x in Alpha_4[m_lim:-m_lim]]), (A[l,m_lim:-m_lim]*np.conjugate(A[l,m_lim+1:m_2mlim])+Am[l,m_lim:-m_lim]*np.conjugate(Am[l,m_lim+1:m_2mlim]))* T_x)
    else:
        A = C*np.sqrt(2)
        # if l == 0:
        #     T_xyl = 0
        # else:
        T_xyl = - spc.epsilon_0/(4*(k)**3) * np.dot(np.asarray([cmath.sqrt(x) for x in Alpha_4[m_lim:-m_lim]]), A[l,m_lim:-m_lim]*np.conjugate(A[l,m_lim+1:m_2mlim]) * T_x)

    T_xl = np.real(T_xyl)
    T_yl = np.imag(T_xyl)
    return T_xl, T_yl